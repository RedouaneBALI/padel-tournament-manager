<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SeedPlacementUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">io.github.redouanebali.generation.util</a> &gt; <span class="el_source">SeedPlacementUtil.java</span></div><h1>SeedPlacementUtil.java</h1><pre class="source lang-java linenums">package io.github.redouanebali.generation.util;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.github.redouanebali.model.Game;
import io.github.redouanebali.model.PlayerPair;
import io.github.redouanebali.model.Pool;
import io.github.redouanebali.model.Round;
import io.github.redouanebali.model.TeamSide;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

/**
 * Utility for placing seeded teams in tournaments. Extracted logic from KnockoutPhase to make it reusable.
 */
<span class="nc" id="L20">public class SeedPlacementUtil {</span>

  /**
   * Places seeded teams in their theoretical positions in a round.
   *
   * @param round the round to place teams in
   * @param playerPairs the list of player pairs (should be sorted by seed)
   * @param nbSeeds number of seeds to place
   * @param drawSize the size of the draw (must match actual slots)
   * @throws IllegalArgumentException if parameters are invalid
   * @throws IllegalStateException if slots are already occupied or drawSize mismatch
   */
  public static void placeSeedTeams(Round round, List&lt;PlayerPair&gt; playerPairs, int nbSeeds, int drawSize) {
<span class="pc bpc" id="L33" title="1 of 8 branches missed.">    if (round == null || round.getGames() == null || playerPairs == null || nbSeeds == 0) {</span>
<span class="fc" id="L34">      return;</span>
    }

<span class="fc bfc" id="L37" title="All 2 branches covered.">    if (nbSeeds &lt; 0) {</span>
<span class="fc" id="L38">      throw new IllegalArgumentException(&quot;nbSeeds cannot be negative&quot;);</span>
    }

<span class="fc bfc" id="L41" title="All 2 branches covered.">    if (drawSize &lt; 0) {</span>
<span class="fc" id="L42">      throw new IllegalArgumentException(&quot;drawSize cannot be negative&quot;);</span>
    }

<span class="fc" id="L45">    final List&lt;Game&gt; games = round.getGames();</span>
<span class="fc" id="L46">    final int        slots = games.size() * 2;</span>

<span class="pc bpc" id="L48" title="1 of 4 branches missed.">    if (drawSize != 0 &amp;&amp; drawSize != slots) {</span>
<span class="fc" id="L49">      throw new IllegalStateException(&quot;Configured drawSize=&quot; + drawSize + &quot; but games provide slots=&quot; + slots);</span>
    }

    // Calculate how many BYEs will be needed
<span class="fc" id="L53">    int byesToPlace = Math.max(0, drawSize - playerPairs.size());</span>

    // Determine how many teams we need to place at theoretical positions
    // This includes official seeds + additional teams at theoretical positions for BYEs
<span class="fc" id="L57">    int teamsToPlaceAtSeedPositions = Math.max(nbSeeds, byesToPlace);</span>
<span class="fc" id="L58">    teamsToPlaceAtSeedPositions = Math.min(teamsToPlaceAtSeedPositions, playerPairs.size());</span>

<span class="pc bpc" id="L60" title="1 of 2 branches missed.">    if (teamsToPlaceAtSeedPositions == 0) {</span>
<span class="nc" id="L61">      return;</span>
    }

    // Sort pairs by seed
<span class="fc" id="L65">    final List&lt;PlayerPair&gt; sortedBySeed = new ArrayList&lt;&gt;(playerPairs);</span>
<span class="fc" id="L66">    sortedBySeed.sort(getSeedComparator());</span>

    // Get theoretical positions
<span class="fc" id="L69">    final List&lt;Integer&gt; seedSlots = getSeedsPositions(drawSize, teamsToPlaceAtSeedPositions);</span>

    // Place teams at theoretical positions
<span class="pc bpc" id="L72" title="2 of 6 branches missed.">    for (int i = 0; i &lt; teamsToPlaceAtSeedPositions &amp;&amp; i &lt; sortedBySeed.size() &amp;&amp; i &lt; seedSlots.size(); i++) {</span>
<span class="fc" id="L73">      int      slot      = seedSlots.get(i);</span>
<span class="fc" id="L74">      int      gameIndex = slot / 2;</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">      TeamSide side      = (slot % 2 == 0) ? TeamSide.TEAM_A : TeamSide.TEAM_B;</span>

<span class="fc" id="L77">      Game       g        = games.get(gameIndex);</span>
<span class="fc" id="L78">      PlayerPair teamPair = sortedBySeed.get(i);</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">      if (side == TeamSide.TEAM_A) {</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (g.getTeamA() == null) {</span>
<span class="fc" id="L82">          g.setTeamA(teamPair);</span>
        } else {
<span class="fc" id="L84">          throw new IllegalStateException(&quot;Seed slot already occupied: game=&quot; + gameIndex + &quot;, side=TEAM_A&quot;);</span>
        }
      } else {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (g.getTeamB() == null) {</span>
<span class="fc" id="L88">          g.setTeamB(teamPair);</span>
        } else {
<span class="nc" id="L90">          throw new IllegalStateException(&quot;Seed slot already occupied: game=&quot; + gameIndex + &quot;, side=TEAM_B&quot;);</span>
        }
      }
    }
<span class="fc" id="L94">  }</span>

  /**
   * Gets seed positions from JSON file.
   */
  public static List&lt;Integer&gt; getSeedsPositions(int drawSize, int nbSeeds) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (nbSeeds == 0) {</span>
<span class="fc" id="L101">      return new ArrayList&lt;&gt;();</span>
    }

<span class="fc" id="L104">    return loadSeedPositionsFromJson(drawSize, nbSeeds);</span>
  }

  /**
   * Public comparator for sorting pairs by seed.
   */
  public static Comparator&lt;PlayerPair&gt; getSeedComparator() {
<span class="fc" id="L111">    return (pair1, pair2) -&gt; {</span>
<span class="fc" id="L112">      int seed1 = pair1.getSeed();</span>
<span class="fc" id="L113">      int seed2 = pair2.getSeed();</span>
<span class="pc bpc" id="L114" title="2 of 4 branches missed.">      if (seed1 &gt; 0 &amp;&amp; seed2 &gt; 0) {</span>
<span class="fc" id="L115">        return Integer.compare(seed1, seed2);</span>
      }
<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (seed1 &gt; 0) {</span>
<span class="nc" id="L118">        return -1;</span>
      }
<span class="nc bnc" id="L120" title="All 2 branches missed.">      if (seed2 &gt; 0) {</span>
<span class="nc" id="L121">        return 1;</span>
      }
<span class="nc" id="L123">      return 0;</span>
    };
  }

  /**
   * Place a list of teams at the given slots in the games list. If allowQualifierOverwrite is true, will overwrite QUALIFIER placeholders.
   */
  public static void placeTeamsAtSlots(List&lt;Game&gt; games, List&lt;PlayerPair&gt; teams, List&lt;Integer&gt; slots, boolean allowQualifierOverwrite) {
<span class="pc bpc" id="L131" title="1 of 4 branches missed.">    for (int i = 0; i &lt; teams.size() &amp;&amp; i &lt; slots.size(); i++) {</span>
<span class="fc" id="L132">      int        slot      = slots.get(i);</span>
<span class="fc" id="L133">      int        gameIndex = slot / 2;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">      TeamSide   side      = (slot % 2 == 0) ? TeamSide.TEAM_A : TeamSide.TEAM_B;</span>
<span class="fc" id="L135">      Game       g         = games.get(gameIndex);</span>
<span class="fc" id="L136">      PlayerPair team      = teams.get(i);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">      if (side == TeamSide.TEAM_A) {</span>
<span class="pc bpc" id="L138" title="5 of 6 branches missed.">        if (g.getTeamA() == null || (allowQualifierOverwrite &amp;&amp; g.getTeamA().getType() == io.github.redouanebali.model.PairType.QUALIFIER)) {</span>
<span class="fc" id="L139">          g.setTeamA(team);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        } else if (!allowQualifierOverwrite) {</span>
<span class="nc" id="L141">          throw new IllegalStateException(&quot;Seed slot already occupied: game=&quot; + gameIndex + &quot;, side=TEAM_A&quot;);</span>
        }
      } else {
<span class="pc bpc" id="L144" title="5 of 6 branches missed.">        if (g.getTeamB() == null || (allowQualifierOverwrite &amp;&amp; g.getTeamB().getType() == io.github.redouanebali.model.PairType.QUALIFIER)) {</span>
<span class="fc" id="L145">          g.setTeamB(team);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        } else if (!allowQualifierOverwrite) {</span>
<span class="nc" id="L147">          throw new IllegalStateException(&quot;Seed slot already occupied: game=&quot; + gameIndex + &quot;, side=TEAM_B&quot;);</span>
        }
      }
    }
<span class="fc" id="L151">  }</span>

  /**
   * Loads seed positions from JSON file.
   */
  private static List&lt;Integer&gt; loadSeedPositionsFromJson(int drawSize, int nbSeeds) {
    try {
      // Load JSON from resources
<span class="fc" id="L159">      InputStream inputStream = SeedPlacementUtil.class.getResourceAsStream(&quot;/seed_positions.json&quot;);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">      if (inputStream == null) {</span>
<span class="nc" id="L161">        throw new IllegalStateException(&quot;seed_positions.json not found in resources&quot;);</span>
      }

<span class="fc" id="L164">      ObjectMapper mapper   = new ObjectMapper();</span>
<span class="fc" id="L165">      JsonNode     rootNode = mapper.readTree(inputStream);</span>

      // Navigate to the correct drawSize
<span class="fc" id="L168">      JsonNode drawSizeNode = rootNode.get(String.valueOf(drawSize));</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">      if (drawSizeNode == null) {</span>
<span class="nc" id="L170">        throw new IllegalArgumentException(&quot;DrawSize &quot; + drawSize + &quot; not supported in seed_positions.json&quot;);</span>
      }

      // If nbSeeds is not a power of 2, use the next power of 2
<span class="fc" id="L174">      int nbSeedsToUse = nbSeeds;</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">      if (nbSeeds &gt; 0 &amp;&amp; (nbSeeds &amp; (nbSeeds - 1)) != 0) {</span>
<span class="fc" id="L176">        nbSeedsToUse = Integer.highestOneBit(nbSeeds) &lt;&lt; 1;</span>
<span class="fc" id="L177">        nbSeedsToUse = Math.min(nbSeedsToUse, drawSize);</span>
      }

<span class="fc" id="L180">      JsonNode nbSeedsNode = drawSizeNode.get(String.valueOf(nbSeedsToUse));</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">      if (nbSeedsNode == null) {</span>
<span class="nc" id="L182">        throw new IllegalArgumentException(&quot;NbSeeds &quot; + nbSeedsToUse + &quot; not supported for drawSize &quot; + drawSize);</span>
      }

<span class="fc" id="L185">      List&lt;Integer&gt; positions = new ArrayList&lt;&gt;();</span>

      // Process seed groups in order: TS1, TS2, TS3-4, etc.
<span class="fc" id="L188">      Iterator&lt;String&gt; fieldNames   = nbSeedsNode.fieldNames();</span>
<span class="fc" id="L189">      List&lt;String&gt;     sortedFields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L190">      fieldNames.forEachRemaining(sortedFields::add);</span>

      // Sort to ensure proper order: TS1, TS2, TS3-4, TS5-8, etc.
<span class="fc" id="L193">      sortedFields.sort((a, b) -&gt; {</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (a.equals(&quot;TS1&quot;)) {</span>
<span class="nc" id="L195">          return -1;</span>
        }
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (b.equals(&quot;TS1&quot;)) {</span>
<span class="fc" id="L198">          return 1;</span>
        }
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (a.equals(&quot;TS2&quot;)) {</span>
<span class="nc" id="L201">          return -1;</span>
        }
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (b.equals(&quot;TS2&quot;)) {</span>
<span class="fc" id="L204">          return 1;</span>
        }
<span class="fc" id="L206">        return a.compareTo(b);</span>
      });

<span class="fc bfc" id="L209" title="All 2 branches covered.">      for (String groupKey : sortedFields) {</span>
<span class="fc" id="L210">        JsonNode      positionsArray = nbSeedsNode.get(groupKey);</span>
<span class="fc" id="L211">        List&lt;Integer&gt; groupPositions = new ArrayList&lt;&gt;();</span>

        // Collect all positions for this group
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (JsonNode posNode : positionsArray) {</span>
<span class="fc" id="L215">          groupPositions.add(posNode.asInt());</span>
<span class="fc" id="L216">        }</span>

        // For TS1 and TS2, use the fixed position
<span class="fc bfc" id="L219" title="All 4 branches covered.">        if (&quot;TS1&quot;.equals(groupKey) || &quot;TS2&quot;.equals(groupKey)) {</span>
<span class="fc" id="L220">          positions.addAll(groupPositions);</span>
        } else {
          // For TS3+, shuffle the positions to simulate a random draw
<span class="fc" id="L223">          Collections.shuffle(groupPositions);</span>
<span class="fc" id="L224">          positions.addAll(groupPositions);</span>
        }
<span class="fc" id="L226">      }</span>

      // Return only the number of seeds requested
<span class="fc" id="L229">      return positions.subList(0, Math.min(nbSeeds, positions.size()));</span>

<span class="nc" id="L231">    } catch (Exception e) {</span>
<span class="nc" id="L232">      throw new RuntimeException(&quot;Failed to load seed positions from JSON&quot;, e);</span>
    }
  }

  /**
   * Places seeded teams in pools for group phase tournaments. Distributes seeds evenly across pools using round-robin distribution.
   *
   * Examples: - 4 pools, 4 seeds → 1 seed per pool (TS1 in Pool A, TS2 in Pool B, etc.) - 4 pools, 8 seeds → 2 seeds per pool (TS1+TS5 in Pool A,
   * TS2+TS6 in Pool B, etc.)
   *
   * @param round the round containing pools
   * @param playerPairs the list of player pairs
   * @param nbPairsPerPool maximum pairs per pool
   */
  public static void placeSeedTeamsInPools(Round round, List&lt;PlayerPair&gt; playerPairs, int nbPairsPerPool) {
<span class="fc bfc" id="L247" title="All 6 branches covered.">    if (round == null || playerPairs == null || round.getPools().isEmpty()) {</span>
<span class="fc" id="L248">      return;</span>
    }

    // Get seeded teams and sort them by seed number
<span class="fc" id="L252">    List&lt;PlayerPair&gt; seededTeams = playerPairs.stream()</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                                              .filter(pair -&gt; pair.getSeed() &gt; 0)</span>
<span class="fc" id="L254">                                              .sorted(getSeedComparator())</span>
<span class="fc" id="L255">                                              .toList();</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">    if (seededTeams.isEmpty()) {</span>
<span class="fc" id="L258">      return;</span>
    }

<span class="fc" id="L261">    List&lt;Pool&gt; pools   = round.getPools();</span>
<span class="fc" id="L262">    int        nbPools = pools.size();</span>

    // Distribute seeds using round-robin approach
    // This ensures even distribution: seed i goes to pool (i % nbPools)
<span class="fc bfc" id="L266" title="All 2 branches covered.">    for (int i = 0; i &lt; seededTeams.size(); i++) {</span>
<span class="fc" id="L267">      PlayerPair seed       = seededTeams.get(i);</span>
<span class="fc" id="L268">      int        poolIndex  = i % nbPools; // Round-robin distribution</span>
<span class="fc" id="L269">      Pool       targetPool = pools.get(poolIndex);</span>

      // Check if pool has space
<span class="fc bfc" id="L272" title="All 2 branches covered.">      if (targetPool.getPairs().size() &lt; nbPairsPerPool) {</span>
<span class="fc" id="L273">        targetPool.addPair(seed);</span>
      } else {
        // If the target pool is full, find the next available pool
<span class="fc" id="L276">        boolean placed = false;</span>
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">        for (int j = 0; j &lt; nbPools &amp;&amp; !placed; j++) {</span>
<span class="fc" id="L278">          int  nextPoolIndex = (poolIndex + j) % nbPools;</span>
<span class="fc" id="L279">          Pool nextPool      = pools.get(nextPoolIndex);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">          if (nextPool.getPairs().size() &lt; nbPairsPerPool) {</span>
<span class="fc" id="L281">            nextPool.addPair(seed);</span>
<span class="fc" id="L282">            placed = true;</span>
          }
        }
        // If no pool has space, the seed cannot be placed (should not happen in normal cases)
      }
    }
<span class="fc" id="L288">  }</span>

  /**
   * Place les seeds dans les pools selon la logique snake officielle. Retourne une liste de pools (List&lt;List&lt;PlayerPair&gt;&gt;) avec les seeds placées.
   */
  public static java.util.List&lt;java.util.List&lt;io.github.redouanebali.model.PlayerPair&gt;&gt; placeSeedsInPoolsSnake(java.util.List&lt;io.github.redouanebali.model.PlayerPair&gt; seeds,
                                                                                                               int nbPools) {
<span class="fc" id="L295">    java.util.List&lt;java.util.List&lt;io.github.redouanebali.model.PlayerPair&gt;&gt; pools = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    for (int i = 0; i &lt; nbPools; i++) {</span>
<span class="fc" id="L297">      pools.add(new java.util.ArrayList&lt;&gt;());</span>
    }
    // Correction : ordre snake = [0, n-1, n-2, ..., 1]
<span class="fc" id="L300">    java.util.List&lt;Integer&gt; snakeOrder = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc" id="L301">    snakeOrder.add(0);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">    for (int i = nbPools - 1; i &gt;= 1; i--) {</span>
<span class="fc" id="L303">      snakeOrder.add(i);</span>
    }
<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (int i = 0; i &lt; seeds.size(); i++) {</span>
<span class="fc" id="L306">      int poolIdx = snakeOrder.get(i % snakeOrder.size());</span>
<span class="fc" id="L307">      pools.get(poolIdx).add(seeds.get(i));</span>
    }
<span class="fc" id="L309">    return pools;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>